/*
[문제 설명]
저희는 서울에서 부산으로 가는 기차들의 실시간 상황을 볼 수 있습니다.
기차들은 n대가 존재하고 각각의 기차는 속도가 다른데, 속도를 나타내는 길이 n의 배열 live가 주어집니다.
기차들은 순차적으로 가야해서 앞 기차를 앞지를 수는 없습니다.
모든 기차들은 다 같이 왼쪽으로 움직이는데 첫번째 인덱스 쪽이 부산이고 마지막 인덱스 쪽이 서울입니다.
만약 뒤에 있는 기차가 속도가 더 빠르다면 앞서가는 기차에 바짝 붙어서 따라가게 되고 같은 속도로 움직이게 되어 하나의 그룹을 형성하게 됩니다.

만약 예를 들어 기차가 5대가 있고 [10, 13, 5, 2, 6]의 속도를 가지고 기차들이 움직이고 있다면,
속도가 앞 기차보다 빠른 13짜리 기차와 6짜리 기차는 앞 기차의 속도에 맞추어 10과 2의 속도로 움직이게 되어 결과적으로 [10, 10, 5, 2, 2]로 움직이게 되고 3개의 그룹을 형성합니다.

여기에서, 저희는 원격으로 기차들의 속도를 바꿀 수 있습니다. 저희에게 명령이 주어지면 저희는 속도를 바꿀 예정인데, 만약 [2, 4]라는 명령이 주어졌다면 2번째 열차를 4만큼 속도를 줄이라는 뜻의 명령입니다.
이 명령배열이 저희에게 주어지고 명령들을 순차적으로 수행할 때마다 몇 개의 그룹이 만들어지는지 계산하여 결과배열로 반환해주세요.

예를 들면 [10, 13, 5, 2, 6]의 배열이 주어지고, 명령들이 [[2,4], [5,2], [1,5], [3,2]]로 주어졌을 때
저희는 처음 명령을 실행하고 나면 배열은 [10, 9, 5, 2, 6]이 되고 최종적으로 [10, 9, 5, 2, 2]의 속도 결과를 얻게 되어 4개의 그룹이 만들어지게 됩니다.
두 번째 명령을 실행하고 나면 배열은 [10, 9, 5, 2, 4]가 되고 최종적으로 [10, 9, 5, 2, 2]의 속도 결과를 얻게 되어 4개의 그룹이 만들어집니다.
세 번째 명령을 실행하고 나면 배열은 [5, 9, 5, 2, 4]가 되고 최종적으로 [5, 5, 5, 2, 2]가 되어 2개의 그룹이 만들어집니다.
마지막 명령을 실행하고 나면 배열은 [5, 9, 3, 2, 4]가 되고 최종적으로 [5, 5, 3, 2, 2]가 되어 3개의 그룹이 만들어지게 되고, 지금까지의 결과를 모아서 [4, 4, 2, 3]을 반환해주시면 됩니다.

[제한 사항]
- 열차는 1대 이상 1000대 이하가 존재하며 각 열차들의 속도는 0 이상 100,000이하입니다.
- 명령문은 해당열차의 속도 이하로 줄일 수 있도록 명령이 주어집니다.
- 각 열차의 속도는 음수일 수 없습니다.

[입력 형식]
- 현재 열차들의 속도 배열인 live가 주어지고, 명령문들의 이차원 배열인 commands가 주어집니다.

[출력 형식]
- 각 명령을 실행할 때마다 최종적으로 모이는 그룹의 결과를 모든 명령에 대해 실행한 후 그 배열을 반환해주세요.
*/

function solution(live, commands) {
  const answer = [];
  commands.forEach((command) => {
    live[command[0] - 1] = live[command[0] - 1] - command[1];
    let resultSpeed = [...live];
    for (let i = 1; i < resultSpeed.length; i++) {
      if (resultSpeed[i - 1] < resultSpeed[i]) resultSpeed[i] = resultSpeed[i - 1];
    }
    let groupCnt = 1;
    for (let i = 1; i < resultSpeed.length; i++) {
      if (resultSpeed[i - 1] !== resultSpeed[i]) groupCnt++;
    }
    answer.push(groupCnt);
  });
  return answer;
}

// 점수: 1.0/1.0
