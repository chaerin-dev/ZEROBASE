/*
[문제 설명]
 상현이와 성민이는 낱말 게임을 하고 있습니다.
 패턴을 주면 이 패턴대로 한 사람씩 돌아가면서 낱말을 말하는 게임입니다.

 예를 들어, 주어진 패턴 p가 "가나나가" 이고,
 낱말 s가 "드래곤 바나나 바나나 드래곤" 이라고 가정할 때
 게임의 결과는 무승부로 true를 출력합니다.
 > 한 사람이 첫 번째 패턴인 "가" 시점에 특정 낱말을 말합니다.
   ex: "드래곤"
 > 그 다음 사람은 "가" 패턴에 말한 낱말을 제외하고,
 두 번째 패턴인 "나" 시점에 맞는 임의의 낱말을 말합니다.
   ex: "바나나"
 > 그 다음 사람은 세 번째 패턴인 "나" 시점에 맞는 낱말을 말합니다.
   ex: "바나나"
 > 마지막으로 네 번째 패턴인 "가" 시점에 맞는 낱말을 말합니다.
   ex: "드래곤"

 패턴 p와 언급한 낱말들 s가 주어질 때,
 해당 게임이 무승부로 끝났는지를 출력하는 함수, solution을 완성해주세요.

[제한 사항]
 - 각 낱말은 공백이 없는 연속된 문자열입니다.
 - s의 각 낱말은 스페이스(" ")로 구분됩니다.

[입력 형식]
 - p는 길이가 4인 문자열입니다.
 - s는 길이가 1 이상 1,000 이하의 문자열입니다.

[출력 형식]
 - 게임의 결과가 무승부인지를 출력합니다.
*/

// [풀이 요약]
// Case1. 기존에 등장했던 패턴, 현재 제시된 단어가 해당 패턴의 단어와 일치하지 않음
// => 무승부 아님
// Case2. 기존에 등장했던 패턴, 현재 제시된 단어가 해당 패턴의 단어와 일치
// => 다음 패턴 확인
// Case3. 새로운 패턴, 현재 제시된 단어가 기존에 등장했던 단어
// => 무승부 아님
// Case4. 새로운 패턴, 현재 제시된 단어가 새로운 단어
// => 해당 (패턴, 단어)쌍을 map에 추가

function solution(p, s) {
  // 문자열 s의 각 단어를 s_arr에 저장
  let s_arr = s.split(" ");

  answer = true;

  // Map 선언
  map = new Map();

  // 패턴 문자열의 길이 동안 반복
  for (let i = 0; i < p.length; i++) {
    // 만약 기존에 등장했던 패턴이 등장했을 때
    if (map.has(p[i])) {
      // 해당 패턴과 함께 제시되었던 단어와 현재 제시된 단어가 일치하지 않으면
      if (map.get(p[i]) != s_arr[i]) {
        // 무승부가 아님
        answer = false;
      }
    }
    // 만약 새로운 패턴이 등장했을 때
    else {
      // 현재 제시된 단어가 기존에 제시되었던 단어와 일치하면
      if (Array.from(map.values()).includes(s_arr[i])) {
        // 무승부가 아님
        answer = false;
      }
      // 현재 제시된 단어가 새로운 단어이면 (패턴, 단어)쌍을 map에 추가
      else map.set(p[i], s_arr[i]);
    }
  }

  return answer;
}

console.log(solution("가나다라", "바나나 드래곤 스리랑카 오염"));
console.log(solution("가나가라", "바나나 드래곤 바나나 오염"));
console.log(solution("가리리리", "바나나 스키 스키 스키"));
console.log(solution("가나가나", "워터 스키 워터 스키"));
console.log(solution("가나다라", "워터 스키 워터 스키"));
console.log(solution("가나다라", "워터 드래곤 스키 워터"));

// 점수: 0.8/1.0
// pdf의 모든 테스트케이스에 대해 결과가 제대로 나오는데 저는 왜 0.8점을 받았을까요..?
