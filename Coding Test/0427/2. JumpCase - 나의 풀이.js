/*
[문제 설명]
 당신은 수직선 위에 서있습니다.
 그리고 당신은 같은 수직선 위의 n미터 떨어진 목적지로 가려고 합니다.
 당신은 한번에 수직선 위를 k 이하의 정수 거리만큼 이동할 수 있으며,
 처음 이동한 방향으로만 계속 이동할 수 있습니다.
 그리고 직전에 이동한 거리와 같은 거리만큼 다시 이동할 수는 없습니다.

 예를 들어, 3-2-3 순서대로 이동했다면 다음에 3만큼 이동할 수 없습니다.

 수직선 길이 n과 이동 가능한 최대 거리 k가 주어질 때,
 목적지에 도착 가능한 경로의 경우의 수를 출력하는 함수, solution을 완성해주세요.
 결과 값이 매우 클 수 있으니, 1,000,000,007로 나눈 나머지 값을 구해주세요.

[입력 형식]
 - n은 1 이상 1,000 이하의 정수입니다.
 - k는 1 이상 100 이하의 정수입니다.

[출력 형식]
 - 목적지로 도착 가능한 경로의 경우의 수를 1,000,000,007로 나눈 나머지 값을 출력합니다.
*/

// 도착 지점까지 가능한 경우의 수
// = 도착지점에서 1만큼 거슬러간 지점까지 가능한 경우의 수 중 직전에 이동한 거리가 1이 아닌 경우의 수
// + 도착지점에서 2만큼 거슬러간 지점까지 가능한 경우의 수 중 직전에 이동한 거리가 2가 아닌 경우의 수
// + ...
// + 도착지점에서 k만큼 거슬러간 지점까지 가능한 경우의 수 중 직전에 이동한 거리가 k가 아닌 경우의 수

// '직전에 이동한 거리와 같은 거리만큼 다시 이동할 수는 없습니다.' => 직전에 이동한 거리를 저장해줘야 함

function solution(n, k) {
  // lastMove[i][j]: 수직선의 출발 지점에서 i만큼 떨어진 지점으로 가는 모든 경우의 수 중
  // 직전에 j만큼 이동한 경우의 수
  let lastMove = Array.from({ length: n + 1 }, () =>
    Array.from({ length: k + 1 }, () => 0)
  );

  // 수직선의 출발 지점에서 i만큼 떨어진 지점 고려
  for (let i = 1; i <= n; i++) {
    // 해당 지점에서 j만큼 거슬러 올라가기
    for (let j = 1; j <= k; j++) {
      if (i - j < 0) continue;
      if (i - j === 0) lastMove[i][j]++;
      // j만큼 거슬러 올라간 지점에서 직전에 j만큼 이동한 경우를 제외하고 모든 경우의 수를 더해서 lastMove[i][j]에 저장
      else
        lastMove[i][j] =
          lastMove[i - j].reduce((acc, e) => (acc += e)) - lastMove[i - j][j];
      lastMove[i][j] %= 1000000007;
    }
  }

  let answer = lastMove[n].reduce((acc, e) => (acc += e));
  return answer % 1000000007;
}

// 점수: 1.0/1.0
